using HM2.GameSolve.Interfaces;
using HM2.GameSolve.Structures;
using HM2.IoCs;
using HM2.MovableObject;
using NUnit.Framework;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace HM2.Tests.AdapterTests
{
    public class AutoGenerationAdapter
    {
        [SetUp]
        public void Setup()
        {
            //Регистрация зависимости
            Func<UObject, Vector> getVect = (o) =>
            {
                //просто возвращаем текущий вектор объекта
                return o.CurrentVector;
            };
            IoC<Func<UObject, Vector>>.Resolve("IoC.Registration", "getPosition", getVect);

            //Регистрация зависимости
            Func<UObject, Vector> getVel = (o) =>
            {
                //просто возвращаем текущий вектор объекта
                return o.CurrentVector;
            };
            IoC<Func<UObject, Vector>>.Resolve("IoC.Registration", "getVelocity", getVel);


            Func<UObject, Vector, Vector> setVect = (o, v) =>
            {
                o.CurrentVector = v;
                return o.CurrentVector;
            };
            IoC<Func<UObject, Vector, Vector>>.Resolve("IoC.Registration", "setPosition", setVect);

            //Регистрация метода void Finish()
            Action<UObject> finish = (o) =>
            {
                o.Dispose();
            };
            IoC<Action<UObject>>.Resolve("IoC.Registration", "Finish", finish);

            //Регистрация адаптера
            Func<UObject, IMovable> getAdapter = (o) =>
            {
                IMovable movableAdapter = new HM2.AutoGenerated.MovableAdapter(o);
                return movableAdapter;
            };
            IoC<Func<UObject, IMovable>>.Resolve("IoC.Registration", "UObjectAdapter", getAdapter);
        }
        [Test]
        public void CurrentPositionDependency()
        {
            Vector vect = new Vector();
            vect.PositionNow = new Coordinats { X = 12.0, Y = 5.0 };
            UObject obj = new UObject(vect);
            //Создание экземпляра адаптера
            IMovable movableAdapter = IoC<Func<UObject, IMovable>>.Resolve("UObjectAdapter").Invoke(obj);
            //получение вектора объекта
            Vector posNow = movableAdapter.getPosition();

            Assert.AreEqual(12, posNow.PositionNow.X);
            Assert.AreEqual(5, posNow.PositionNow.Y);
        }

        [Test]
        public void RegistrationSetVectorDependency()
        {
            Vector vect = new Vector();
            vect.PositionNow = new Coordinats { X = 0.0, Y = 0.0 };
            UObject obj = new UObject(vect);
            //Создание экземпляра адаптера
            IMovable movableAdapter = IoC<Func<UObject, IMovable>>.Resolve("UObjectAdapter").Invoke(obj);
            //получение вектора объекта
            Vector posNow = movableAdapter.getPosition();
            Assert.AreEqual(0.0, posNow.PositionNow.X);
            Assert.AreEqual(0.0, posNow.PositionNow.Y);

            Vector newVect = new Vector();
            newVect.PositionNow = new Coordinats { X = 20.1, Y = 10.8 };

            //Установка вектора объекта
            Vector velosityVect = movableAdapter.setPosition(newVect);
            Vector posNew = movableAdapter.getPosition();
            Assert.AreEqual(20.1, posNew.PositionNow.X);
            Assert.AreEqual(10.8, posNew.PositionNow.Y);
        }

        [Test]
        public void RegistrationCurrentVelosityDependency()
        {
            const double vel = 0.0;
            const double anglr = 0.0;
            const int anglrVel = 10;
            const int direction = 15;
            const int dirNum = 24;

            Vector vect = new Vector();
            vect.AngularVelosity = anglrVel;
            vect.Direction = direction;
            vect.DirectionNumber = dirNum;
            vect.VelosityVectNow = new VelosityVect { Velosity = vel, Angular = anglr };

            UObject obj = new UObject(vect);
            //Создание экземпляра адаптера
            IMovable movableAdapter = IoC<Func<UObject, IMovable>>.Resolve("UObjectAdapter").Invoke(obj);
            //получение вектора объекта
            Vector velosityVect = movableAdapter.getVelocity();

            Assert.AreEqual(velosityVect.AngularVelosity, anglrVel);
            Assert.AreEqual(velosityVect.Direction, direction);
            Assert.AreEqual(velosityVect.DirectionNumber, dirNum);
            Assert.AreEqual(velosityVect.VelosityVectNow.Angular, anglr);
            Assert.AreEqual(velosityVect.VelosityVectNow.Velosity, vel);
        }

        [Test]
        public void FinishedUObject()
        {
            const double vel = 0.0;
            const double anglr = 0.0;
            const int anglrVel = 10;
            const int direction = 15;
            const int dirNum = 24;

            Vector vect = new Vector();
            vect.AngularVelosity = anglrVel;
            vect.Direction = direction;
            vect.DirectionNumber = dirNum;
            vect.VelosityVectNow = new VelosityVect { Velosity = vel, Angular = anglr };

            UObject obj = new UObject(vect);
            //Создание экземпляра адаптера
            IMovable movableAdapter = IoC<Func<UObject, IMovable>>.Resolve("UObjectAdapter").Invoke(obj);

            //Вызов деструктора UObject
            try
            {
                movableAdapter.Finish();
            }
            catch (Exception ex)
            {
                if (ex.GetType().GetHashCode() != new NotImplementedException().GetType().GetHashCode())
                    Assert.Fail();
            }

        }
    }
}
